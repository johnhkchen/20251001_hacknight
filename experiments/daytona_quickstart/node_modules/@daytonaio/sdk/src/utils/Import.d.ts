declare const loaderMap: {
    'fast-glob': () => Promise<{
        default: typeof import("fast-glob");
        sync(source: import("fast-glob/out/types").Pattern | import("fast-glob/out/types").Pattern[], options: import("fast-glob/out/settings").Options & ({
            objectMode: true;
        } | {
            stats: true;
        })): import("fast-glob/out/types").Entry[];
        sync(source: import("fast-glob/out/types").Pattern | import("fast-glob/out/types").Pattern[], options?: import("fast-glob/out/settings").Options): string[];
        stream(source: import("fast-glob/out/types").Pattern | import("fast-glob/out/types").Pattern[], options?: import("fast-glob/out/settings").Options): NodeJS.ReadableStream;
        generateTasks(source: import("fast-glob/out/types").Pattern | import("fast-glob/out/types").Pattern[], options?: import("fast-glob/out/settings").Options): import("fast-glob").Task[];
        isDynamicPattern(source: import("fast-glob/out/types").Pattern, options?: import("fast-glob/out/settings").Options): boolean;
        escapePath(source: string): import("fast-glob/out/types").Pattern;
        convertPathToPattern(source: string): import("fast-glob/out/types").Pattern;
        glob: typeof import("fast-glob");
        globSync: typeof import("fast-glob").sync;
        globStream: typeof import("fast-glob").stream;
        async: typeof import("fast-glob");
        posix: typeof import("fast-glob").posix;
        win32: typeof import("fast-glob").win32;
    }>;
    '@iarna/toml': () => Promise<{
        default: typeof import("@iarna/toml");
        parse: import("@iarna/toml").FuncParse;
        stringify: import("@iarna/toml").FuncStringify;
    }>;
    stream: () => Promise<{
        default: typeof import("stream");
        Stream: typeof import("stream");
        promises: typeof import("node:stream/promises");
        duplexPair(options?: import("stream").DuplexOptions): [import("stream").Duplex, import("stream").Duplex];
        addAbortSignal<T extends import("stream")>(signal: AbortSignal, stream: T): T;
        getDefaultHighWaterMark(objectMode: boolean): number;
        setDefaultHighWaterMark(objectMode: boolean, value: number): void;
        finished: typeof import("stream").finished;
        pipeline: typeof import("stream").pipeline;
        isErrored(stream: import("stream").Readable | import("stream").Writable | NodeJS.ReadableStream | NodeJS.WritableStream): boolean;
        isReadable(stream: import("stream").Readable | NodeJS.ReadableStream): boolean;
        Readable: typeof import("stream").Readable;
        Writable: typeof import("stream").Writable;
        Duplex: typeof import("stream").Duplex;
        Transform: typeof import("stream").Transform;
        PassThrough: typeof import("stream").PassThrough;
        errorMonitor: typeof import("events").errorMonitor;
        captureRejectionSymbol: typeof import("events").captureRejectionSymbol;
        captureRejections: boolean;
        defaultMaxListeners: number;
        EventEmitter: typeof import("events");
        EventEmitterAsyncResource: typeof import("events").EventEmitterAsyncResource;
    }>;
    tar: () => Promise<{
        default: typeof import("tar");
        Extract(opts: import("tar").ExtractOptions | string): import("tar").ParseStream;
        create(options: import("tar").CreateOptions, fileList: readonly string[], callback?: (err?: Error) => void): import("stream").Readable;
        create(options: import("tar").CreateOptions & import("tar").FileOptions, fileList: readonly string[]): Promise<void>;
        create(options: import("tar").CreateOptions & import("tar").FileOptions & {
            sync: true;
        }, fileList: readonly string[]): void;
        create(options: import("tar").CreateOptions & import("tar").FileOptions, fileList: readonly string[], callback: (err?: Error) => void): void;
        extract(options: import("tar").ExtractOptions, fileList?: readonly string[], callback?: (err?: Error) => void): import("stream").Writable;
        extract(options: import("tar").ExtractOptions & import("tar").FileOptions, fileList?: readonly string[]): Promise<void>;
        extract(options: import("tar").ExtractOptions & import("tar").FileOptions & {
            sync: true;
        }, fileList?: readonly string[]): void;
        extract(options: import("tar").ExtractOptions & import("tar").FileOptions, fileList: readonly string[] | undefined, callback: (err?: Error) => void): void;
        list(options: import("tar").ListOptions & import("tar").RequiredFileOptions, fileList?: readonly string[]): Promise<void>;
        list(options: import("tar").ListOptions & import("tar").RequiredFileOptions & {
            sync: true;
        }, fileList?: readonly string[]): void;
        list(callback?: (err?: Error) => void): import("tar").Parse;
        list(optionsOrFileList: import("tar").ListOptions | readonly string[], callback?: (err?: Error) => void): import("tar").Parse;
        list(options: import("tar").ListOptions, fileList: readonly string[], callback?: (err?: Error) => void): import("tar").Parse;
        replace(options: import("tar").ReplaceOptions, fileList?: readonly string[]): Promise<void>;
        replace(options: import("tar").ReplaceOptions, fileList: readonly string[] | undefined, callback: (err?: Error) => void): Promise<void>;
        update(options: import("tar").ReplaceOptions, fileList?: readonly string[]): Promise<void>;
        update(options: import("tar").ReplaceOptions, fileList: readonly string[] | undefined, callback: (err?: Error) => void): Promise<void>;
        fieldSize: number[];
        fieldOffs: number[];
        fieldEnds: number[];
        types: {
            0: string;
            "\0": string;
            "": string;
            1: string;
            2: string;
            3: string;
            4: string;
            5: string;
            6: string;
            7: string;
            g: string;
            x: string;
            A: string;
            D: string;
            I: string;
            K: string;
            L: string;
            M: string;
            N: string;
            S: string;
            V: string;
            X: string;
            File: string;
            OldFile: string;
            Link: string;
            SymbolicLick: string;
            CharacterDevice: string;
            BlockDevice: string;
            Directory: string;
            FIFO: string;
            ContiguousFile: string;
            GlobalExtendedHeader: string;
            ExtendedHeader: string;
            SolarisACL: string;
            GNUDumpDir: string;
            INode: string;
            NextFileHasLonLinkPath: string;
            NextFileHasLongPath: string;
            ContinuationFile: string;
            TapeVolumeHeader: string;
            OldExtendedHeader: string;
        };
        modes: {
            suid: number;
            sgid: number;
            svtx: number;
            uread: number;
            uwrite: number;
            uexec: number;
            gread: number;
            gwrite: number;
            gexec: number;
            oread: number;
            owrite: number;
            oexec: number;
        };
        numeric: {
            mode: boolean;
            uid: boolean;
            gid: boolean;
            size: boolean;
            mtime: boolean;
            devmaj: boolean;
            devmin: boolean;
            cksum: boolean;
            atime: boolean;
            ctime: boolean;
            dev: boolean;
            ino: boolean;
            nlink: boolean;
        };
        knownExtended: {
            atime: boolean;
            charset: boolean;
            comment: boolean;
            ctime: boolean;
            gid: boolean;
            gname: boolean;
            linkpat: boolean;
            mtime: boolean;
            path: boolean;
            realtime: boolean;
            security: boolean;
            size: boolean;
            uid: boolean;
            uname: boolean;
        };
        headerSize: number;
        blockSize: number;
        Parse: {
            new (opt?: import("tar").ParseOptions): import("tar").Parse;
        };
        Pack: typeof import("tar").Pack;
        c: typeof import("tar").create;
        x: typeof import("tar").extract;
        t: typeof import("tar").list;
        r: typeof import("tar").replace;
        u: typeof import("tar").update;
    }>;
    'expand-tilde': () => Promise<any>;
    ObjectStorage: () => Promise<{
        default: typeof import("../ObjectStorage");
        ObjectStorage: typeof import("../ObjectStorage").ObjectStorage;
    }>;
    fs: () => Promise<typeof import("fs")>;
    'form-data': () => Promise<{
        default: typeof import("form-data");
        Stream: typeof import("stream");
        promises: typeof import("node:stream/promises");
        duplexPair(options?: import("stream").DuplexOptions): [import("stream").Duplex, import("stream").Duplex];
        addAbortSignal<T extends import("stream")>(signal: AbortSignal, stream: T): T;
        getDefaultHighWaterMark(objectMode: boolean): number;
        setDefaultHighWaterMark(objectMode: boolean, value: number): void;
        finished: typeof import("stream").finished;
        pipeline: typeof import("stream").pipeline;
        isErrored(stream: import("stream").Readable | import("stream").Writable | NodeJS.ReadableStream | NodeJS.WritableStream): boolean;
        isReadable(stream: import("stream").Readable | NodeJS.ReadableStream): boolean;
        Readable: typeof import("stream").Readable;
        Writable: typeof import("stream").Writable;
        Duplex: typeof import("stream").Duplex;
        Transform: typeof import("stream").Transform;
        PassThrough: typeof import("stream").PassThrough;
        errorMonitor: typeof import("events").errorMonitor;
        captureRejectionSymbol: typeof import("events").captureRejectionSymbol;
        captureRejections: boolean;
        defaultMaxListeners: number;
        EventEmitter: typeof import("events");
        EventEmitterAsyncResource: typeof import("events").EventEmitterAsyncResource;
    }>;
};
declare const requireMap: {
    'fast-glob': () => any;
    '@iarna/toml': () => any;
    stream: () => any;
    tar: () => any;
    'expand-tilde': () => any;
    fs: () => any;
    'form-data': () => any;
};
type ModuleMap = typeof loaderMap;
export declare function dynamicImport<K extends keyof ModuleMap>(name: K, errorPrefix?: string): Promise<Awaited<ReturnType<ModuleMap[K]>>>;
type RequireMap = typeof requireMap;
export declare function dynamicRequire<K extends keyof RequireMap>(name: K, errorPrefix?: string): ReturnType<RequireMap[K]>;
export {};
