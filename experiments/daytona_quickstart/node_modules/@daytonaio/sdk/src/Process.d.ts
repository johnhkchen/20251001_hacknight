import { Command, Configuration, Session, SessionExecuteRequest, SessionExecuteResponse as ApiSessionExecuteResponse, PortPreviewUrl, ToolboxApi } from '@daytonaio/api-client';
import { SandboxCodeToolbox } from './Sandbox';
import { ExecuteResponse } from './types/ExecuteResponse';
export declare const STDOUT_PREFIX_BYTES: Uint8Array<ArrayBuffer>;
export declare const STDERR_PREFIX_BYTES: Uint8Array<ArrayBuffer>;
export declare const MAX_PREFIX_LEN: number;
/**
 * Parameters for code execution.
 */
export declare class CodeRunParams {
    /**
     * Command line arguments
     */
    argv?: string[];
    /**
     * Environment variables
     */
    env?: Record<string, string>;
}
export interface SessionExecuteResponse extends ApiSessionExecuteResponse {
    stdout?: string;
    stderr?: string;
}
export interface SessionCommandLogsResponse {
    output?: string;
    stdout?: string;
    stderr?: string;
}
/**
 * Handles process and code execution within a Sandbox.
 *
 * @class
 */
export declare class Process {
    private readonly sandboxId;
    private readonly clientConfig;
    private readonly codeToolbox;
    private readonly toolboxApi;
    private readonly getPreviewLink;
    constructor(sandboxId: string, clientConfig: Configuration, codeToolbox: SandboxCodeToolbox, toolboxApi: ToolboxApi, getPreviewLink: (port: number) => Promise<PortPreviewUrl>);
    /**
     * Executes a shell command in the Sandbox.
     *
     * @param {string} command - Shell command to execute
     * @param {string} [cwd] - Working directory for command execution. If not specified, uses the sandbox working directory.
     * @param {Record<string, string>} [env] - Environment variables to set for the command
     * @param {number} [timeout] - Maximum time in seconds to wait for the command to complete. 0 means wait indefinitely.
     * @returns {Promise<ExecuteResponse>} Command execution results containing:
     *                                    - exitCode: The command's exit status
     *                                    - result: Standard output from the command
     *                                    - artifacts: ExecutionArtifacts object containing `stdout` (same as result) and `charts` (matplotlib charts metadata)
     *
     * @example
     * // Simple command
     * const response = await process.executeCommand('echo "Hello"');
     * console.log(response.artifacts.stdout);  // Prints: Hello
     *
     * @example
     * // Command with working directory
     * const result = await process.executeCommand('ls', 'workspace/src');
     *
     * @example
     * // Command with timeout
     * const result = await process.executeCommand('sleep 10', undefined, 5);
     */
    executeCommand(command: string, cwd?: string, env?: Record<string, string>, timeout?: number): Promise<ExecuteResponse>;
    /**
     * Executes code in the Sandbox using the appropriate language runtime.
     *
     * @param {string} code - Code to execute
     * @param {CodeRunParams} params - Parameters for code execution
     * @param {number} [timeout] - Maximum time in seconds to wait for execution to complete
     * @returns {Promise<ExecuteResponse>} Code execution results containing:
     *                                    - exitCode: The execution's exit status
     *                                    - result: Standard output from the code
     *                                    - artifacts: ExecutionArtifacts object containing `stdout` (same as result) and `charts` (matplotlib charts metadata)
     *
     * @example
     * // Run TypeScript code
     * const response = await process.codeRun(`
     *   const x = 10;
     *   const y = 20;
     *   console.log(\`Sum: \${x + y}\`);
     * `);
     * console.log(response.artifacts.stdout);  // Prints: Sum: 30
     *
     * @example
     * // Run Python code with matplotlib
     * const response = await process.codeRun(`
     * import matplotlib.pyplot as plt
     * import numpy as np
     *
     * x = np.linspace(0, 10, 30)
     * y = np.sin(x)
     *
     * plt.figure(figsize=(8, 5))
     * plt.plot(x, y, 'b-', linewidth=2)
     * plt.title('Line Chart')
     * plt.xlabel('X-axis (seconds)')
     * plt.ylabel('Y-axis (amplitude)')
     * plt.grid(True)
     * plt.show()
     * `);
     *
     * if (response.artifacts?.charts) {
     *   const chart = response.artifacts.charts[0];
     *
     *   console.log(`Type: ${chart.type}`);
     *   console.log(`Title: ${chart.title}`);
     *   if (chart.type === ChartType.LINE) {
     *     const lineChart = chart as LineChart
     *     console.log('X Label:', lineChart.x_label)
     *     console.log('Y Label:', lineChart.y_label)
     *     console.log('X Ticks:', lineChart.x_ticks)
     *     console.log('Y Ticks:', lineChart.y_ticks)
     *     console.log('X Tick Labels:', lineChart.x_tick_labels)
     *     console.log('Y Tick Labels:', lineChart.y_tick_labels)
     *     console.log('X Scale:', lineChart.x_scale)
     *     console.log('Y Scale:', lineChart.y_scale)
     *     console.log('Elements:')
     *     console.dir(lineChart.elements, { depth: null })
     *   }
     * }
     */
    codeRun(code: string, params?: CodeRunParams, timeout?: number): Promise<ExecuteResponse>;
    /**
     * Creates a new long-running background session in the Sandbox.
     *
     * Sessions are background processes that maintain state between commands, making them ideal for
     * scenarios requiring multiple related commands or persistent environment setup. You can run
     * long-running commands and monitor process status.
     *
     * @param {string} sessionId - Unique identifier for the new session
     * @returns {Promise<void>}
     *
     * @example
     * // Create a new session
     * const sessionId = 'my-session';
     * await process.createSession(sessionId);
     * const session = await process.getSession(sessionId);
     * // Do work...
     * await process.deleteSession(sessionId);
     */
    createSession(sessionId: string): Promise<void>;
    /**
     * Get a session in the sandbox.
     *
     * @param {string} sessionId - Unique identifier of the session to retrieve
     * @returns {Promise<Session>} Session information including:
     *                            - sessionId: The session's unique identifier
     *                            - commands: List of commands executed in the session
     *
     * @example
     * const session = await process.getSession('my-session');
     * session.commands.forEach(cmd => {
     *   console.log(`Command: ${cmd.command}`);
     * });
     */
    getSession(sessionId: string): Promise<Session>;
    /**
     * Gets information about a specific command executed in a session.
     *
     * @param {string} sessionId - Unique identifier of the session
     * @param {string} commandId - Unique identifier of the command
     * @returns {Promise<Command>} Command information including:
     *                            - id: The command's unique identifier
     *                            - command: The executed command string
     *                            - exitCode: Command's exit status (if completed)
     *
     * @example
     * const cmd = await process.getSessionCommand('my-session', 'cmd-123');
     * if (cmd.exitCode === 0) {
     *   console.log(`Command ${cmd.command} completed successfully`);
     * }
     */
    getSessionCommand(sessionId: string, commandId: string): Promise<Command>;
    /**
     * Executes a command in an existing session.
     *
     * @param {string} sessionId - Unique identifier of the session to use
     * @param {SessionExecuteRequest} req - Command execution request containing:
     *                                     - command: The command to execute
     *                                     - runAsync: Whether to execute asynchronously
     * @param {number} timeout - Timeout in seconds
     * @returns {Promise<SessionExecuteResponse>} Command execution results containing:
     *                                           - cmdId: Unique identifier for the executed command
     *                                           - output: Combined command output (stdout and stderr) (if synchronous execution)
     *                                           - stdout: Standard output from the command
     *                                           - stderr: Standard error from the command
     *                                           - exitCode: Command exit status (if synchronous execution)
     *
     * @example
     * // Execute commands in sequence, maintaining state
     * const sessionId = 'my-session';
     *
     * // Change directory
     * await process.executeSessionCommand(sessionId, {
     *   command: 'cd /home/daytona'
     * });
     *
     * // Run command in new directory
     * const result = await process.executeSessionCommand(sessionId, {
     *   command: 'pwd'
     * });
     * console.log('[STDOUT]:', result.stdout);
     * console.log('[STDERR]:', result.stderr);
     */
    executeSessionCommand(sessionId: string, req: SessionExecuteRequest, timeout?: number): Promise<SessionExecuteResponse>;
    /**
     * Get the logs for a command executed in a session.
     *
     * @param {string} sessionId - Unique identifier of the session
     * @param {string} commandId - Unique identifier of the command
     * @returns {Promise<SessionCommandLogsResponse>} Command logs containing: output (combined stdout and stderr), stdout and stderr
     *
     * @example
     * const logs = await process.getSessionCommandLogs('my-session', 'cmd-123');
     * console.log('[STDOUT]:', logs.stdout);
     * console.log('[STDERR]:', logs.stderr);
     */
    getSessionCommandLogs(sessionId: string, commandId: string): Promise<SessionCommandLogsResponse>;
    /**
     * Asynchronously retrieve and process the logs for a command executed in a session as they become available.
     *
     * @param {string} sessionId - Unique identifier of the session
     * @param {string} commandId - Unique identifier of the command
     * @param {function} onStdout - Callback function to handle stdout log chunks
     * @param {function} onStderr - Callback function to handle stderr log chunks
     * @returns {Promise<void>}
     *
     * @example
     * const logs = await process.getSessionCommandLogs('my-session', 'cmd-123', (chunk) => {
     *   console.log('[STDOUT]:', chunk);
     * }, (chunk) => {
     *   console.log('[STDERR]:', chunk);
     * });
     */
    getSessionCommandLogs(sessionId: string, commandId: string, onStdout: (chunk: string) => void, onStderr: (chunk: string) => void): Promise<void>;
    /**
     * Lists all active sessions in the Sandbox.
     *
     * @returns {Promise<Session[]>} Array of active sessions
     *
     * @example
     * const sessions = await process.listSessions();
     * sessions.forEach(session => {
     *   console.log(`Session ${session.sessionId}:`);
     *   session.commands.forEach(cmd => {
     *     console.log(`- ${cmd.command} (${cmd.exitCode})`);
     *   });
     * });
     */
    listSessions(): Promise<Session[]>;
    /**
     * Delete a session from the Sandbox.
     *
     * @param {string} sessionId - Unique identifier of the session to delete
     * @returns {Promise<void>}
     *
     * @example
     * // Clean up a completed session
     * await process.deleteSession('my-session');
     */
    deleteSession(sessionId: string): Promise<void>;
}
