"use strict";
/*
 * Copyright 2025 Daytona Platforms Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileSystem = void 0;
const tslib_1 = require("tslib");
const pathe = tslib_1.__importStar(require("pathe"));
const form_data_1 = tslib_1.__importDefault(require("form-data"));
const Import_1 = require("./utils/Import");
const Runtime_1 = require("./utils/Runtime");
const busboy_1 = tslib_1.__importDefault(require("busboy"));
const DaytonaError_1 = require("./errors/DaytonaError");
/**
 * Provides file system operations within a Sandbox.
 *
 * @class
 */
class FileSystem {
    sandboxId;
    clientConfig;
    toolboxApi;
    constructor(sandboxId, clientConfig, toolboxApi) {
        this.sandboxId = sandboxId;
        this.clientConfig = clientConfig;
        this.toolboxApi = toolboxApi;
    }
    /**
     * Create a new directory in the Sandbox with specified permissions.
     *
     * @param {string} path - Path where the directory should be created. Relative paths are resolved based on the sandbox working directory.
     * @param {string} mode - Directory permissions in octal format (e.g. "755")
     * @returns {Promise<void>}
     *
     * @example
     * // Create a directory with standard permissions
     * await fs.createFolder('app/data', '755');
     */
    async createFolder(path, mode) {
        const response = await this.toolboxApi.createFolder(this.sandboxId, path, mode);
        return response.data;
    }
    /**
     * Deletes a file or directory from the Sandbox.
     *
     * @param {string} path - Path to the file or directory to delete. Relative paths are resolved based on the sandbox working directory.
     * @param {boolean} [recursive] - If the file is a directory, this must be true to delete it.
     * @returns {Promise<void>}
     *
     * @example
     * // Delete a file
     * await fs.deleteFile('app/temp.log');
     */
    async deleteFile(path, recursive) {
        const response = await this.toolboxApi.deleteFile(this.sandboxId, path, undefined, recursive);
        return response.data;
    }
    async downloadFile(src, dst, timeout = 30 * 60) {
        const remotePath = src;
        if (typeof dst !== 'string') {
            if (dst) {
                timeout = dst;
            }
            const response = await this.downloadFiles([{ source: remotePath }], timeout);
            if (response[0].error) {
                throw new DaytonaError_1.DaytonaError(response[0].error);
            }
            return response[0].result;
        }
        const response = await this.downloadFiles([{ source: remotePath, destination: dst }], timeout);
        if (response[0].error) {
            throw new DaytonaError_1.DaytonaError(response[0].error);
        }
    }
    /**
     * Downloads multiple files from the Sandbox. If the files already exist locally, they will be overwritten.
     *
     * @param {FileDownloadRequest[]} files - Array of file download requests.
     * @param {number} [timeoutSec] - Timeout for the download operation in seconds. 0 means no timeout.
     * Default is 30 minutes.
     * @returns {Promise<FileDownloadResponse[]>} Array of download results.
     *
     * @throws {DaytonaError} If the request itself fails (network issues, invalid request/response, etc.). Individual
     * file download errors are returned in the `FileDownloadResponse.error` field.
     *
     * @example
     * // Download multiple files
     * const results = await fs.downloadFiles([
     *   { source: 'tmp/data.json' },
     *   { source: 'tmp/config.json', destination: 'local_config.json' }
     * ]);
     * results.forEach(result => {
     *   if (result.error) {
     *     console.error(`Error downloading ${result.source}: ${result.error}`);
     *   } else if (result.result) {
     *     console.log(`Downloaded ${result.source} to ${result.result}`);
     *   }
     * });
     */
    async downloadFiles(files, timeoutSec = 30 * 60) {
        if (files.length === 0)
            return [];
        const srcFileMetaMap = new Map();
        const fileTasks = [];
        for (const f of files) {
            srcFileMetaMap.set(f.source, { dst: f.destination });
            if (f.destination) {
                const fs = await (0, Import_1.dynamicImport)('fs', 'Downloading files to local files is not supported: ');
                await fs.promises.mkdir(pathe.dirname(f.destination), { recursive: true });
            }
        }
        const response = await this.toolboxApi.downloadFiles(this.sandboxId, { paths: Array.from(srcFileMetaMap.keys()) }, undefined, {
            responseType: 'stream',
            timeout: timeoutSec * 1000,
        });
        const responseData = response.data;
        await new Promise((resolve, reject) => {
            const bb = (0, busboy_1.default)({
                headers: response.headers,
                preservePath: true,
            });
            bb.on('file', (partType, fileStream, fileInfo) => {
                const source = fileInfo.filename;
                if (!source) {
                    // Unexpected file from upstream, reject the request
                    responseData.destroy();
                    reject(new DaytonaError_1.DaytonaError(`Received unexpected file "${fileInfo.filename}".`));
                    return;
                }
                const meta = srcFileMetaMap.get(source);
                if (!meta) {
                    responseData.destroy();
                    reject(new DaytonaError_1.DaytonaError(`Target metadata missing for valid source: ${source}`));
                    return;
                }
                if (partType === 'error') {
                    let buf = Buffer.alloc(0);
                    fileStream.on('data', (chunk) => {
                        buf = Buffer.concat([buf, chunk]);
                    });
                    fileStream.on('end', () => {
                        meta.error = buf.toString('utf-8').trim();
                    });
                    fileStream.on('error', (err) => {
                        meta.error = `Stream error: ${err.message}`;
                    });
                }
                else if (partType === 'file') {
                    if (meta.dst) {
                        fileTasks.push(new Promise((resolve) => {
                            (0, Import_1.dynamicImport)('fs', 'Downloading files to local files is not supported: ').then((fs) => {
                                const writeStream = fs.createWriteStream(meta.dst, { autoClose: true });
                                fileStream.pipe(writeStream);
                                writeStream.on('finish', () => {
                                    meta.result = meta.dst;
                                    resolve();
                                });
                                writeStream.on('error', (err) => {
                                    meta.error = `Write stream failed: ${err.message}`;
                                    resolve();
                                });
                                fileStream.on('error', (err) => {
                                    meta.error = `Read stream failed: ${err.message}`;
                                });
                            });
                        }));
                    }
                    else {
                        const chunks = [];
                        fileStream.on('data', (chunk) => {
                            chunks.push(chunk);
                        });
                        fileStream.on('end', () => {
                            meta.result = Buffer.concat(chunks);
                        });
                        fileStream.on('error', (err) => {
                            meta.error = `Read failed: ${err.message}`;
                        });
                    }
                }
                else {
                    fileStream.resume();
                }
            });
            bb.on('error', (err) => {
                responseData.destroy();
                reject(err);
            });
            bb.on('finish', resolve);
            responseData.pipe(bb);
        });
        await Promise.all(fileTasks);
        const results = [];
        for (const f of files) {
            const meta = srcFileMetaMap.get(f.source);
            let err = meta?.error;
            if (!err && !meta?.result) {
                err = 'No data received for this file';
            }
            let res;
            if (!err && meta) {
                res = meta.result;
            }
            else if (!meta) {
                err = 'No writer metadata found';
            }
            results.push({
                source: f.source,
                result: res,
                error: err,
            });
        }
        return results;
    }
    /**
     * Searches for text patterns within files in the Sandbox.
     *
     * @param {string} path - Directory to search in. Relative paths are resolved based on the sandbox working directory.
     * @param {string} pattern - Search pattern
     * @returns {Promise<Array<Match>>} Array of matches with file and line information
     *
     * @example
     * // Find all TODO comments in TypeScript files
     * const matches = await fs.findFiles('app/src', 'TODO:');
     * matches.forEach(match => {
     *   console.log(`${match.file}:${match.line}: ${match.content}`);
     * });
     */
    async findFiles(path, pattern) {
        const response = await this.toolboxApi.findInFiles(this.sandboxId, path, pattern);
        return response.data;
    }
    /**
     * Retrieves detailed information about a file or directory.
     *
     * @param {string} path - Path to the file or directory. Relative paths are resolved based on the sandbox working directory.
     * @returns {Promise<FileInfo>} Detailed file information including size, permissions, modification time
     *
     * @example
     * // Get file details
     * const info = await fs.getFileDetails('app/config.json');
     * console.log(`Size: ${info.size}, Modified: ${info.modTime}`);
     */
    async getFileDetails(path) {
        const response = await this.toolboxApi.getFileInfo(this.sandboxId, path);
        return response.data;
    }
    /**
     * Lists contents of a directory in the Sandbox.
     *
     * @param {string} path - Directory path to list. Relative paths are resolved based on the sandbox working directory.
     * @returns {Promise<FileInfo[]>} Array of file and directory information
     *
     * @example
     * // List directory contents
     * const files = await fs.listFiles('app/src');
     * files.forEach(file => {
     *   console.log(`${file.name} (${file.size} bytes)`);
     * });
     */
    async listFiles(path) {
        const response = await this.toolboxApi.listFiles(this.sandboxId, undefined, path);
        return response.data;
    }
    /**
     * Moves or renames a file or directory.
     *
     * @param {string} source - Source path. Relative paths are resolved based on the sandbox working directory.
     * @param {string} destination - Destination path. Relative paths are resolved based on the sandbox working directory.
     * @returns {Promise<void>}
     *
     * @example
     * // Move a file to a new location
     * await fs.moveFiles('app/temp/data.json', 'app/data/data.json');
     */
    async moveFiles(source, destination) {
        const response = await this.toolboxApi.moveFile(this.sandboxId, source, destination);
        return response.data;
    }
    /**
     * Replaces text content in multiple files.
     *
     * @param {string[]} files - Array of file paths to process. Relative paths are resolved based on the sandbox working directory.
     * @param {string} pattern - Pattern to replace
     * @param {string} newValue - Replacement text
     * @returns {Promise<Array<ReplaceResult>>} Results of the replace operation for each file
     *
     * @example
     * // Update version number across multiple files
     * const results = await fs.replaceInFiles(
     *   ['app/package.json', 'app/version.ts'],
     *   '"version": "1.0.0"',
     *   '"version": "1.1.0"'
     * );
     */
    async replaceInFiles(files, pattern, newValue) {
        const replaceRequest = {
            files,
            newValue,
            pattern,
        };
        const response = await this.toolboxApi.replaceInFiles(this.sandboxId, replaceRequest);
        return response.data;
    }
    /**
     * Searches for files and directories by name pattern in the Sandbox.
     *
     * @param {string} path - Directory to search in. Relative paths are resolved based on the sandbox working directory.
     * @param {string} pattern - File name pattern (supports globs)
     * @returns {Promise<SearchFilesResponse>} Search results with matching files
     *
     * @example
     * // Find all TypeScript files
     * const result = await fs.searchFiles('app', '*.ts');
     * result.files.forEach(file => console.log(file));
     */
    async searchFiles(path, pattern) {
        const response = await this.toolboxApi.searchFiles(this.sandboxId, path, pattern);
        return response.data;
    }
    /**
     * Sets permissions and ownership for a file or directory.
     *
     * @param {string} path - Path to the file or directory. Relative paths are resolved based on the sandbox working directory.
     * @param {FilePermissionsParams} permissions - Permission settings
     * @returns {Promise<void>}
     *
     * @example
     * // Set file permissions and ownership
     * await fs.setFilePermissions('app/script.sh', {
     *   owner: 'daytona',
     *   group: 'users',
     *   mode: '755'  // Execute permission for shell script
     * });
     */
    async setFilePermissions(path, permissions) {
        const response = await this.toolboxApi.setFilePermissions(this.sandboxId, path, undefined, permissions.owner, permissions.group, permissions.mode);
        return response.data;
    }
    async uploadFile(src, dst, timeout = 30 * 60) {
        await this.uploadFiles([{ source: src, destination: dst }], timeout);
    }
    /**
     * Uploads multiple files to the Sandbox. If files already exist at the destination paths,
     * they will be overwritten.
     *
     * @param {FileUpload[]} files - Array of files to upload.
     * @param {number} [timeout] - Timeout for the upload operation in seconds. 0 means no timeout.
     * Default is 30 minutes.
     * @returns {Promise<void>}
     *
     * @example
     * // Upload multiple text files
     * const files = [
     *   {
     *     source: Buffer.from('Content of file 1'),
     *     destination: '/tmp/file1.txt'
     *   },
     *   {
     *     source: 'app/data/file2.txt',
     *     destination: '/tmp/file2.txt'
     *   },
     *   {
     *     source: Buffer.from('{"key": "value"}'),
     *     destination: '/tmp/config.json'
     *   }
     * ];
     * await fs.uploadFiles(files);
     */
    async uploadFiles(files, timeout = 30 * 60) {
        // Use native FormData in Deno
        const FormDataClass = Runtime_1.RUNTIME === Runtime_1.Runtime.DENO || Runtime_1.RUNTIME === Runtime_1.Runtime.SERVERLESS
            ? form_data_1.default
            : (await (0, Import_1.dynamicImport)('form-data', 'Uploading files is not supported: '));
        const form = new FormDataClass();
        for (const [i, { source, destination }] of files.entries()) {
            form.append(`files[${i}].path`, destination);
            const payload = await this.makeFilePayload(source);
            // the third arg sets filename in Content-Disposition
            form.append(`files[${i}].file`, payload, destination);
        }
        if (Runtime_1.RUNTIME === Runtime_1.Runtime.SERVERLESS) {
            const url = `${this.clientConfig.basePath}/toolbox/${this.sandboxId}/toolbox/files/bulk-upload`;
            await fetch(url, {
                method: 'POST',
                headers: this.clientConfig.baseOptions.headers,
                body: form,
                signal: timeout ? AbortSignal.timeout(timeout * 1000) : undefined,
            });
        }
        else {
            await this.toolboxApi.uploadFiles(this.sandboxId, undefined, {
                data: form,
                maxRedirects: 0,
                timeout: timeout * 1000,
            });
        }
    }
    async makeFilePayload(source) {
        // 1) file‐path
        if (typeof source === 'string') {
            const fs = await (0, Import_1.dynamicImport)('fs', 'Uploading file from local file system is not supported: ');
            return fs.createReadStream(source);
        }
        // 2) browser → Blob
        if (Runtime_1.RUNTIME === Runtime_1.Runtime.BROWSER || Runtime_1.RUNTIME === Runtime_1.Runtime.SERVERLESS) {
            return new Blob([source], { type: 'application/octet-stream' });
        }
        // 3) Node (or other server runtimes) → stream.Readable
        const stream = await (0, Import_1.dynamicImport)('stream', 'Uploading file is not supported: ');
        return stream.Readable.from(source);
    }
}
exports.FileSystem = FileSystem;
//# sourceMappingURL=FileSystem.js.map